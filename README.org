* yet another lisp
A lisp that tries to look like clojure with topological sorting by dependencies before evaluation.
Run with =go run cmd/gowen/*= or install with =go install github.com/niklasfasching/gowen/cmd/gowen=

#+BEGIN_SRC clojure
(reduce (fn [_ x] (printf "%-30T %-20s %s" x (type x) x))
        nil
        [0 "foo" :bar 'baz [] {} ()])
;; float64                        number               %!s(float64=0)
;; string                         string               foo
;; gowen.Keyword                  keyword              :bar
;; gowen.Symbol                   symbol               baz
;; gowen.Vector                   vector               []
;; map[interface {}]interface {}  hashmap              map[]
;; gowen.List                     list                 []
nil

(let [[x & xs :as original] [1 2 3]] [x xs original])
;; [1 (2 3) [1 2 3]]

(let [{:keys [x y z] :as m} {:x 1 :y 2}] [x y m])
;; [1 2 {:y 2, :x 1}]
#+END_SRC
* features and non features
- !performance - pretty/concise > fast
- !complex hashmaps
  golang doesn't support uncomparable values in maps. This means stuff like ={(+ 1 2) 3}= is impossible to write.
  sadly, this also prevents a naive implementation of nested destructuring in maps like =(let [{[x & xs] :xs} {:xs [1 2 3]}])=
- clojure like destructuring (as far as easily implementable)
- easy interop with go (using reflection)
- order independent evaluation - toplevel forms are sorted to allow forward references and "circular" dependencies across files
  #+BEGIN_SRC clojure
  (def bar (+ foo 1))
  (def foo 1)
  #+END_SRC
* next
* resources
- https://github.com/jcla1/gisp
- https://blog.burntsushi.net/type-parametric-functions-golang/
- [[https://web.wpi.edu/Pubs/ETD/Available/etd-090110-124904/unrestricted/jshutt.pdf][fexprs as the basis of Lisp function application]]
- L.I.S.P.: Lisp In Small Pieces
- http://axisofeval.blogspot.com/2013/04/a-quasiquote-i-can-understand.html
